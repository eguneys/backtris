var Tetris=function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=0)}([function(n,e,t){n.exports=t(1)},function(n,e,t){t(2);const o=t(3);n.exports=o.app},function(n,e,t){},function(n,e,t){"use strict";function o(n,e){const t={unit:30,width:n,height:e,ratio:e/n,vx:10,tick:0};return{game:t,hero:{radius:t.unit/2,gap:2,gapMove:2,rotation:0,tick:0}}}t.r(e);const r=Math.PI;const a={identity:function(){return[1,0,0,0,1,0,0,0,1]},transform:function(n,e,t,o,r){let i=a.identity();return i=a.multiply(i,a.projection(n[0],n[1])),i=a.multiply(i,a.translation(e[0],e[1])),i=a.multiply(i,a.translation(r[0],r[1])),i=a.multiply(i,a.rotation(t)),i=a.multiply(i,a.scaling(o[0],o[1])),i=a.multiply(i,a.translation(-r[0],-r[1]))},projection:function(n,e){return[2/n,0,0,0,-2/e,0,-1,1,1]},translation:function(n,e){return[1,0,0,0,1,0,n,e,1]},rotation:function(n){var e=Math.cos(n),t=Math.sin(n);return[e,-t,0,t,e,0,0,0,1]},scaling:function(n,e){return[n,0,0,0,e,0,0,0,1]},multiply:function(n,e){var t=n[0],o=n[1],r=n[2],a=n[3],i=n[4],c=n[5],l=n[6],u=n[7],s=n[8],f=e[0],d=e[1],p=e[2],v=e[3],m=e[4],h=e[5],b=e[6],g=e[7],x=e[8];return[f*t+d*a+p*l,f*o+d*i+p*u,f*r+d*c+p*s,v*t+m*a+h*l,v*o+m*i+h*u,v*r+m*c+h*s,b*t+g*a+x*l,b*o+g*i+x*u,b*r+g*c+x*s]}};var i=a,c="#version 300 es\n\nprecision mediump float;\n\nin vec2 aPosition;\n\nin vec2 aTexCoord;\n\nout vec2 vQuadCoord;\n\nuniform vec2 uResolution;\n\nuniform mat3 uMatrix;\n\nvoid main() {\n\n  vec2 position = (uMatrix * vec3(aPosition, 1)).xy;\n\n  vQuadCoord = aTexCoord;\n\n  gl_Position = vec4(position, 0, 1);\n\n}\n",l="#version 300 es\n\n#define PI 3.14\n#define HALFPI (PI * 0.5)\n#define TAU (PI * 2.0)\n \nprecision mediump float;\n\nuniform float uTime;\nuniform vec2 uResolution;\n\nuniform vec2 uSqueeze;\n\nin vec2 vQuadCoord;\n\nout vec4 outColor;\n\nfloat usin(float v) {\n  return (sin(v) + 1.0) / 2.0;\n}\n\nfloat sdEquilateralTriangle( in vec2 p ) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox(vec2 p, vec2 b, float r )\n{\n  return sdBox(p, b) - r;\n}\n\nfloat opBlend(float d1, float d2, float a)\n{\n return a * d1 + (1.0 - a) * d2;\n}\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nvec2 opRep(vec2 p, vec2 c)\n{\n  vec2 q = mod(p,c)-0.5*c;\n  return q;\n}\n\nvec2 screenToWorld(vec2 screen) {\n  vec2 result = 2.0 * (screen/uResolution.xy - 0.5);\n  result.x *= uResolution.x/uResolution.y;\n  return result;\n}\n\nvec2 screenToWorld2(vec2 screen) {\n  screen.x *= uResolution.x/uResolution.y;\n  return screen;\n}\n\nmat3 affineMatrix(vec2 translation, float rotation, float scaling) {\n  return mat3(scaling*cos(rotation), -sin(rotation), 0.0,\n              sin(rotation), scaling*cos(rotation), 0.0,\n              translation.x, translation.y, 1.0);\n}\n\nvec2 transform(vec2 p, vec2 trans, float rotate, float scale) {\n  //p = (-inverse(affineMatrix(vec2(0.0, 0.0), 0.0, 1.0)) * vec3(p, 1.0)).xy;\n  p = (-inverse(affineMatrix(trans, rotate, scale)) * vec3(p, 1.0)).xy;\n  // p = (-inverse(affineMatrix(vec2(-0.0, -0.0), 0.0, 1.0)) * vec3(p, 1.0)).xy;\n  return p;\n}\n\nvec2 translate(vec2 p, vec2 trans) {\n  return transform(p, trans, 0.0, 1.0);\n}\n\nvec2 rotate(vec2 p, float angle) {\n  return transform(p, vec2(0.0), angle, 1.0);\n}\n\nfloat sdHeroBubble(vec2 p, vec2 trans, float rot) {\n  vec2 pBubbles = \n    transform(p, trans, rot, 1.0);\n  float bubbles = sdCircle(pBubbles, 0.5);\n\n  return bubbles;\n}\n\n\nvoid heroColor(out vec4 col, vec2 p) {\n\n  vec2 p2 = rotate(p, uSqueeze.x);\n  float wedgeBox = sdRoundedBox(p2, vec2(0.5, 0.01), 0.2);\n\n  vec2 pSmall = transform(p, vec2(0.0), 0.0, 1.0);\n  float wedgeCircle = sdCircle(pSmall, 0.4);\n  \n  float wedge = opBlend(wedgeBox, wedgeCircle, \n                        uSqueeze.y);\n\n  float hero = wedge;\n\n  col = mix(col, vec4(1.0, 0.0, 0.0, 1.0), 1.0-smoothstep(0.0, 0.02, hero));\n}\n\nvoid wallColor(out vec4 col, vec2 p) {\n  float wall = sdLine(p, vec2(0.0), vec2(-1.0));\n\n  col = mix(col, vec4(1.0, 0.0, 1.0, 1.0), 1.0-smoothstep(0.0, 0.01,abs(wall)));\n}\n\nvoid sceneColor(out vec4 col, vec2 p) {\n\n  heroColor(col, p);\n  wallColor(col, p);\n}\n\n\nvoid main() {\n\n  vec2 p = vQuadCoord;//screenToWorld2(vQuadCoord);\n\n  vec4 col = vec4(0.5, 0.5, 0.5, 0.0);\n\n  sceneColor(col, p);\n\n  outColor = col;\n}\n";function u(n,e){const{width:t,height:o}=n.game;e.clearColor(0,0,0,1),e.blendFunc(e.SRC_ALPHA,e.ONE),e.enable(e.BLEND),e.disable(e.DEPTH_TEST),this.minibatch=[];const a=.5*o;let u=function(n,e,t,o){let r=v(n,n.VERTEX_SHADER,c),a=v(n,n.FRAGMENT_SHADER,l),i=function(n,e,t){let o=n.createProgram();if(n.attachShader(o,e),n.attachShader(o,t),n.linkProgram(o),n.getProgramParameter(o,n.LINK_STATUS))return o;return console.error(n.getProgramInfoLog(o)),n.deleteProgram(o),null}(n,r,a),u=n.getAttribLocation(i,"aPosition"),s=n.createBuffer(),f=n.createVertexArray();n.bindVertexArray(f),n.enableVertexAttribArray(u),n.bindBuffer(n.ARRAY_BUFFER,s);let d=0,p=t,m=0,h=o,b=[d,m,d,h,p,m,d,h,p,m,p,h];n.bufferData(n.ARRAY_BUFFER,new Float32Array(b),n.STATIC_DRAW);let g=2,x=n.FLOAT,y=!1,A=0,R=0;n.vertexAttribPointer(u,g,x,y,A,R);let w=n.getAttribLocation(i,"aTexCoord"),S=n.createBuffer();return n.bindBuffer(n.ARRAY_BUFFER,S),b=[d=-1,m=-1,d,h=1,p=1,m,d,h,p,m,p,h],n.bufferData(n.ARRAY_BUFFER,new Float32Array(b),n.STATIC_DRAW),n.enableVertexAttribArray(w),g=2,x=n.FLOAT,y=!0,A=0,R=0,n.vertexAttribPointer(w,g,x,y,A,R),{width:t,height:o,program:i,vao:f,uniforms:(T=e,C=(e,t)=>t(n,i),Object.keys(T).reduce((n,e)=>({[e]:C(e,T[e]),...n}),{}))};var T,C}(e,{uSqueeze:d("uSqueeze"),uResolution:f("uResolution"),uTime:s("uTime"),uMatrix:p("uMatrix")},a,a);this.addHero=n=>{h(u,{uSqueeze:[n.squeeze],uTime:[n.tick],...m(n)})};const m=({pivot:n,translation:r,rotation:a,scale:c})=>{const l=i.transform([t,o],r,a,c,n);return{uResolution:[e.canvas.width,e.canvas.height],uMatrix:[l]}},h=(n,e)=>{const t=Object.keys(n.uniforms).map(t=>{let o=n.uniforms[t],r=e[t];return()=>{o(...r)}});this.minibatch.push({...n,uniforms:t})};this.render=()=>{this.addHero({tick:n.game.tick,squeeze:[0*r,1],translation:[.5*t-.5*a,.5*o-.5*a],rotation:0*Math.PI,scale:[1,1],pivot:[.5*a,.5*a]}),e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT),this.minibatch.forEach(({program:n,uniforms:t,vao:o})=>{e.useProgram(n),t.forEach(n=>n()),e.bindVertexArray(o),e.drawArrays(e.TRIANGLES,0,6)}),this.minibatch=[]}}const s=n=>(e,t)=>(...o)=>e.uniform1f(e.getUniformLocation(t,n),...o),f=n=>(e,t)=>(...o)=>e.uniform2f(e.getUniformLocation(t,n),...o),d=n=>(e,t)=>o=>e.uniform2fv(e.getUniformLocation(t,n),o),p=n=>(e,t)=>o=>e.uniformMatrix3fv(e.getUniformLocation(t,n),!1,o);function v(n,e,t){let o=n.createShader(e);return n.shaderSource(o,t),n.compileShader(o),n.getShaderParameter(o,n.COMPILE_STATUS)?o:(console.error(n.getShaderInfoLog(o)),n.deleteShader(o),null)}function m(n,e){const{width:t,height:o}=n.data.game;this.render=n=>{}}function h(n,e){this.data=n,this.update=n=>{this.data.game.tick+=n}}const b=void 0!==window.performance?window.performance:Date,g=()=>b.now(),x=window.requestAnimationFrame;function y(n){let e=!1,t=g(),o=0;this.start=()=>e?this:(e=!0,t=g(),o=x(r),this),this.stop=()=>(e=!1,0!=o&&x.cancel(o),o=0,this);const r=()=>{o=x(r);const e=g();n(e-t),t=e}}function A(n,e){const t=document.createElement("canvas"),r=t.getContext("webgl2");n.append(t);const a=t.clientWidth,i=t.clientHeight;t.width=a,t.height=i;const c={...o(a,i)};let l=new u(c,r),s=new h(c,l),f=new m(s,l);new y(n=>{s.update(n),f.render(s),l.render()}).start()}t.d(e,"app",function(){return A})}]);